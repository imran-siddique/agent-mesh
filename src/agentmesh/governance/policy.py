"""
Policy Engine

Declarative policy engine with YAML/JSON policies.
Policy evaluation latency <5ms with 100% deterministic results.
"""

from datetime import datetime
from typing import Optional, Literal, Any, Callable
from pydantic import BaseModel, Field
import yaml
import json
import re


class PolicyRule(BaseModel):
    """
    A single policy rule.
    
    Rules define conditions and actions:
    - condition: Expression that evaluates to true/false
    - action: What to do when condition matches (allow, deny, warn, require_approval)
    """
    
    name: str = Field(..., description="Rule name")
    description: Optional[str] = Field(None)
    
    # Condition
    condition: str = Field(..., description="Condition expression")
    
    # Action
    action: Literal["allow", "deny", "warn", "require_approval", "log"] = Field(
        default="deny"
    )
    
    # Rate limiting
    limit: Optional[str] = Field(None, description="Rate limit (e.g., '100/hour')")
    
    # Approval workflow
    approvers: list[str] = Field(default_factory=list)
    
    # Priority (higher = evaluated first)
    priority: int = Field(default=0)
    
    # Enabled
    enabled: bool = Field(default=True)
    
    def evaluate(self, context: dict) -> bool:
        """
        Evaluate the condition against a context.
        
        Supports simple expressions like:
        - action.type == 'export'
        - data.contains_pii
        - user.role in ['admin', 'operator']
        """
        if not self.enabled:
            return False
        
        try:
            # Simple expression evaluation
            # In production, would use a proper expression parser
            return self._eval_expression(self.condition, context)
        except Exception:
            return False
    
    def _eval_expression(self, expr: str, context: dict) -> bool:
        """Evaluate a simple expression."""
        # Handle compound conditions first (AND/OR)
        # This must be checked before individual conditions
        
        # OR conditions
        if " or " in expr:
            parts = expr.split(" or ")
            return any(self._eval_expression(p.strip(), context) for p in parts)
        
        # AND conditions
        if " and " in expr:
            parts = expr.split(" and ")
            return all(self._eval_expression(p.strip(), context) for p in parts)
        
        # Now handle atomic conditions
        
        # Equality: action.type == 'export'
        eq_match = re.match(r"(\w+(?:\.\w+)*)\s*==\s*['\"]([^'\"]+)['\"]", expr)
        if eq_match:
            path, value = eq_match.groups()
            actual = self._get_nested(context, path)
            return actual == value
        
        # Boolean attribute: data.contains_pii
        bool_match = re.match(r"^(\w+(?:\.\w+)*)$", expr)
        if bool_match:
            path = bool_match.group(1)
            return bool(self._get_nested(context, path))
        
        return False
    
    def _get_nested(self, obj: dict, path: str) -> Any:
        """Get nested value from dict using dot notation."""
        parts = path.split(".")
        current = obj
        for part in parts:
            if isinstance(current, dict):
                current = current.get(part)
            else:
                return None
        return current


class Policy(BaseModel):
    """
    Complete policy document.
    
    Policies are defined in YAML/JSON and loaded at runtime.
    """
    
    version: str = Field(default="1.0")
    name: str = Field(...)
    description: Optional[str] = Field(None)
    
    # Target
    agent: Optional[str] = Field(None, description="Agent this policy applies to")
    agents: list[str] = Field(default_factory=list, description="Multiple agents")
    
    # Rules
    rules: list[PolicyRule] = Field(default_factory=list)
    
    # Default action
    default_action: Literal["allow", "deny"] = Field(default="deny")
    
    # Metadata
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    
    @classmethod
    def from_yaml(cls, yaml_content: str) -> "Policy":
        """Load policy from YAML."""
        data = yaml.safe_load(yaml_content)
        
        # Parse rules
        rules = []
        for rule_data in data.get("rules", []):
            rules.append(PolicyRule(**rule_data))
        data["rules"] = rules
        
        return cls(**data)
    
    @classmethod
    def from_json(cls, json_content: str) -> "Policy":
        """Load policy from JSON."""
        data = json.loads(json_content)
        
        rules = []
        for rule_data in data.get("rules", []):
            rules.append(PolicyRule(**rule_data))
        data["rules"] = rules
        
        return cls(**data)
    
    def applies_to(self, agent_did: str) -> bool:
        """Check if this policy applies to an agent."""
        if self.agent and self.agent == agent_did:
            return True
        if agent_did in self.agents:
            return True
        if "*" in self.agents:
            return True
        return False
    
    def to_yaml(self) -> str:
        """Export policy as YAML."""
        data = self.model_dump(exclude_none=True)
        # Convert rules to dicts
        data["rules"] = [r.model_dump(exclude_none=True) for r in self.rules]
        return yaml.dump(data, default_flow_style=False)


class PolicyDecision(BaseModel):
    """Result of policy evaluation."""
    
    allowed: bool
    action: Literal["allow", "deny", "warn", "require_approval", "log"]
    
    # Which rule matched
    matched_rule: Optional[str] = None
    policy_name: Optional[str] = None
    
    # Details
    reason: Optional[str] = None
    
    # For require_approval
    approvers: list[str] = Field(default_factory=list)
    
    # For rate limiting
    rate_limited: bool = False
    rate_limit_reset: Optional[datetime] = None
    
    # Timing
    evaluated_at: datetime = Field(default_factory=datetime.utcnow)
    evaluation_ms: Optional[float] = None


class PolicyEngine:
    """
    Declarative policy engine.
    
    Features:
    - YAML/JSON policy definitions
    - <5ms evaluation latency
    - 100% deterministic across runs
    - Rate limiting support
    - Approval workflows
    """
    
    MAX_EVAL_MS = 5  # Target: <5ms evaluation
    
    def __init__(self):
        self._policies: dict[str, Policy] = {}
        self._rate_limits: dict[str, dict] = {}  # rule_name -> {count, reset_at}
        self._rego_evaluators: list[tuple[str, Any]] = []  # [(package, OPAEvaluator)]
    
    def load_policy(self, policy: Policy) -> None:
        """Load a policy into the engine."""
        self._policies[policy.name] = policy
    
    def load_yaml(self, yaml_content: str) -> Policy:
        """Load policy from YAML string."""
        policy = Policy.from_yaml(yaml_content)
        self.load_policy(policy)
        return policy
    
    def load_json(self, json_content: str) -> Policy:
        """Load policy from JSON string."""
        policy = Policy.from_json(json_content)
        self.load_policy(policy)
        return policy
    
    def _apply_rule(self, rule: PolicyRule, policy: Policy, context: Optional[dict] = None) -> PolicyDecision:
        """Apply a matched rule and generate actionable error messages."""
        # Check rate limit if applicable
        if rule.limit:
            if self._is_rate_limited(rule):
                return PolicyDecision(
                    allowed=False,
                    action="deny",
                    matched_rule=rule.name,
                    policy_name=policy.name,
                    reason=f"Rate limit exceeded for rule '{rule.name}': {rule.limit}. Wait for rate limit to reset.",
                    rate_limited=True,
                )
            self._increment_rate_limit(rule)
        
        # Build actionable error message
        if rule.action == "deny":
            # Build detailed, actionable message
            action_type = context.get("action", {}).get("type", "action") if context else "action"
            suggestion = self._get_suggestion(rule, context)
            reason = (
                f"Policy '{policy.name}' blocked {action_type}. "
                f"Rule: '{rule.name}'. "
                f"Reason: {rule.description or 'Policy condition matched'}. "
                f"{suggestion}"
            )
        elif rule.action == "require_approval":
            approver_list = ", ".join(rule.approvers) if rule.approvers else "designated approvers"
            reason = (
                f"Action requires approval from {approver_list}. "
                f"Policy: '{policy.name}', Rule: '{rule.name}'."
            )
        elif rule.action == "warn":
            reason = (
                f"Warning from policy '{policy.name}': {rule.description or rule.name}. "
                f"Action allowed but logged for review."
            )
        else:
            reason = rule.description or f"Matched rule: {rule.name}"
        
        return PolicyDecision(
            allowed=(rule.action == "allow"),
            action=rule.action,
            matched_rule=rule.name,
            policy_name=policy.name,
            reason=reason,
            approvers=rule.approvers if rule.action == "require_approval" else [],
        )
    
    def _get_suggestion(self, rule: PolicyRule, context: Optional[dict] = None) -> str:
        """Generate actionable suggestions based on the rule condition."""
        condition = rule.condition.lower()
        
        # Pattern-based suggestions
        if "pii" in condition or "contains_pii" in condition:
            return "Suggestion: Remove PII fields or request approval from data privacy team."
        elif "export" in condition:
            return "Suggestion: Use internal data only or request export approval."
        elif "admin" in condition or "role" in condition:
            return "Suggestion: Request elevated permissions or contact your administrator."
        elif "external" in condition or "domain" in condition:
            return "Suggestion: Use approved internal services or request external access."
        elif "budget" in condition or "cost" in condition:
            return "Suggestion: Reduce request scope or request budget increase."
        elif "time" in condition or "hour" in condition:
            return "Suggestion: Retry during allowed hours or request exception."
        else:
            return "Suggestion: Review policy requirements or contact administrator."
    
    def _is_rate_limited(self, rule: PolicyRule) -> bool:
        """Check if a rule is rate limited."""
        if not rule.limit:
            return False
        
        limit_key = rule.name
        limit_data = self._rate_limits.get(limit_key)
        
        if not limit_data:
            return False
        
        # Check if reset time passed
        if datetime.utcnow() > limit_data["reset_at"]:
            self._rate_limits[limit_key] = None
            return False
        
        # Parse limit (e.g., "100/hour")
        count, period = self._parse_limit(rule.limit)
        
        return limit_data["count"] >= count
    
    def _increment_rate_limit(self, rule: PolicyRule) -> None:
        """Increment rate limit counter."""
        if not rule.limit:
            return
        
        limit_key = rule.name
        count, period = self._parse_limit(rule.limit)
        
        if limit_key not in self._rate_limits or self._rate_limits[limit_key] is None:
            from datetime import timedelta
            self._rate_limits[limit_key] = {
                "count": 0,
                "reset_at": datetime.utcnow() + timedelta(seconds=period),
            }
        
        self._rate_limits[limit_key]["count"] += 1
    
    def _parse_limit(self, limit: str) -> tuple[int, int]:
        """Parse a limit string like '100/hour'."""
        parts = limit.split("/")
        count = int(parts[0])
        
        period_map = {
            "second": 1,
            "minute": 60,
            "hour": 3600,
            "day": 86400,
        }
        
        period = period_map.get(parts[1], 3600)
        return count, period
    
    def get_policy(self, name: str) -> Optional[Policy]:
        """Get a policy by name."""
        return self._policies.get(name)
    
    def list_policies(self) -> list[str]:
        """List all loaded policy names."""
        return list(self._policies.keys())
    
    def remove_policy(self, name: str) -> bool:
        """Remove a policy."""
        if name in self._policies:
            del self._policies[name]
            return True
        return False

    # ── OPA/Rego integration ──────────────────────────────────

    def load_rego(self, rego_path: Optional[str] = None, rego_content: Optional[str] = None, package: str = "agentmesh") -> "OPAEvaluator":
        """
        Load a .rego file alongside YAML/JSON policies.

        The OPA evaluator runs in parallel: YAML rules are checked first,
        and if no rule matches, the Rego policy is consulted.

        Args:
            rego_path: Path to a .rego file
            rego_content: Inline Rego policy string
            package: Rego package name (used to build query path)

        Returns:
            OPAEvaluator instance for direct use
        """
        from agentmesh.governance.opa import OPAEvaluator
        evaluator = OPAEvaluator(mode="local", rego_path=rego_path, rego_content=rego_content)
        self._rego_evaluators.append((package, evaluator))
        return evaluator

    def evaluate(
        self,
        agent_did: str,
        context: dict,
    ) -> PolicyDecision:
        """
        Evaluate all applicable policies for an action.

        Order: YAML/JSON rules first, then Rego policies.
        """
        start = datetime.utcnow()

        # 1. Check YAML/JSON policies first
        applicable = [p for p in self._policies.values() if p.applies_to(agent_did)]

        if applicable:
            all_rules = []
            for policy in applicable:
                for rule in policy.rules:
                    all_rules.append((policy, rule))

            all_rules.sort(key=lambda x: x[1].priority, reverse=True)

            for policy, rule in all_rules:
                if rule.evaluate(context):
                    decision = self._apply_rule(rule, policy, context)
                    elapsed = (datetime.utcnow() - start).total_seconds() * 1000
                    decision.evaluation_ms = elapsed
                    return decision

        # 2. Check Rego policies
        for package, evaluator in self._rego_evaluators:
            query = f"data.{package}.allow"
            opa_result = evaluator.evaluate(query, context)
            if opa_result.error is None:
                elapsed = (datetime.utcnow() - start).total_seconds() * 1000
                return PolicyDecision(
                    allowed=opa_result.allowed,
                    action="allow" if opa_result.allowed else "deny",
                    reason=f"OPA/Rego policy ({package}): {'allowed' if opa_result.allowed else 'denied'}",
                    evaluated_at=start,
                    evaluation_ms=elapsed,
                )

        # 3. No rules matched - use default
        if applicable:
            default = applicable[0].default_action
        else:
            default = "allow"  # No policies = default allow

        elapsed = (datetime.utcnow() - start).total_seconds() * 1000
        return PolicyDecision(
            allowed=(default == "allow"),
            action=default,
            reason="No matching rules, using default",
            evaluated_at=start,
            evaluation_ms=elapsed,
        )
