"""
Trust Handshake

IATP-compatible trust handshakes for cross-agent and cross-cloud
communication. Handshake completes in <200ms.
"""

from datetime import datetime, timedelta
from typing import Any, Optional, Literal
from pydantic import BaseModel, Field
import hashlib
import secrets
import asyncio
from agentmesh.constants import TIER_TRUSTED_THRESHOLD, TIER_VERIFIED_PARTNER_THRESHOLD
from agentmesh.identity.agent_id import AgentIdentity
from agentmesh.identity.delegation import UserContext
from agentmesh.exceptions import HandshakeError, HandshakeTimeoutError


class HandshakeChallenge(BaseModel):
    """Challenge issued during a trust handshake.

    A challenge contains a cryptographic nonce that the peer must sign
    to prove its identity.

    Attributes:
        challenge_id: Unique identifier for this challenge.
        nonce: Cryptographic nonce (hex-encoded) the peer must sign.
        timestamp: UTC time the challenge was created.
        expires_in_seconds: Seconds until the challenge expires.
    """
    
    challenge_id: str
    nonce: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    expires_in_seconds: int = 30
    
    @classmethod
    def generate(cls) -> "HandshakeChallenge":
        """Generate a new challenge with a random nonce.

        Returns:
            A fresh ``HandshakeChallenge`` with a unique ID and
            cryptographically random nonce.
        """
        return cls(
            challenge_id=f"challenge_{secrets.token_hex(8)}",
            nonce=secrets.token_hex(32),
        )
    
    def is_expired(self) -> bool:
        """Check if the challenge has exceeded its time-to-live.

        Returns:
            ``True`` if the elapsed time since creation exceeds
            ``expires_in_seconds``.
        """
        elapsed = (datetime.utcnow() - self.timestamp).total_seconds()
        return elapsed > self.expires_in_seconds


class HandshakeResponse(BaseModel):
    """Response to a handshake challenge.

    Contains the peer's attestation (capabilities, trust score) and a
    cryptographic proof binding the response to the original challenge.

    Attributes:
        challenge_id: ID of the challenge being responded to.
        response_nonce: Fresh nonce generated by the responder.
        agent_did: Responder's decentralized identifier.
        capabilities: Capability strings the responder attests.
        trust_score: Self-reported trust score (0–1000).
        signature: Cryptographic signature over the challenge and
            response payload.
        public_key: Public key for signature verification.
        user_context: Optional end-user context for on-behalf-of
            (OBO) flows.
        timestamp: UTC time the response was created.
    """
    
    challenge_id: str
    response_nonce: str
    
    # Agent attestation
    agent_did: str
    capabilities: list[str] = Field(default_factory=list)
    trust_score: int = Field(default=0, ge=0, le=1000)
    
    # Cryptographic proof
    signature: str  # Signature over challenge + response
    public_key: str  # For verification

    # User context for OBO flows
    user_context: Optional[dict] = Field(None, description="End-user context for OBO flows")

    # Metadata
    timestamp: datetime = Field(default_factory=datetime.utcnow)


class HandshakeResult(BaseModel):
    """Result of a trust handshake.

    Captures verification outcome, trust details, timing, and an
    optional rejection reason.

    Attributes:
        verified: Whether the handshake succeeded.
        peer_did: The peer's decentralized identifier.
        peer_name: Optional human-readable peer name.
        trust_score: Verified trust score (0–1000).
        trust_level: Categorical trust tier derived from the score.
        capabilities: Capabilities attested by the peer.
        user_context: Propagated end-user context from OBO flow.
        handshake_started: UTC timestamp when the handshake began.
        handshake_completed: UTC timestamp when it finished.
        latency_ms: Round-trip handshake latency in milliseconds.
        rejection_reason: Human-readable reason if verification
            failed.
    """
    
    verified: bool
    peer_did: str
    peer_name: Optional[str] = None
    
    # Trust details
    trust_score: int = Field(default=0, ge=0, le=1000)
    trust_level: Literal["verified_partner", "trusted", "standard", "untrusted"] = "untrusted"
    
    # Capabilities
    capabilities: list[str] = Field(default_factory=list)

    # User context (propagated from OBO flow)
    user_context: Optional[UserContext] = Field(None, description="End-user context if acting on behalf of a user")

    # Timing
    handshake_started: datetime = Field(default_factory=datetime.utcnow)
    handshake_completed: Optional[datetime] = None
    latency_ms: Optional[int] = None
    
    # Rejection reason (if not verified)
    rejection_reason: Optional[str] = None
    
    @classmethod
    def success(
        cls,
        peer_did: str,
        trust_score: int,
        capabilities: list[str],
        peer_name: Optional[str] = None,
        started: Optional[datetime] = None,
        user_context: Optional[UserContext] = None,
    ) -> "HandshakeResult":
        """Create a successful handshake result.

        Automatically computes latency and determines the trust level
        tier based on the score.

        Args:
            peer_did: The verified peer's DID.
            trust_score: Verified trust score (0–1000).
            capabilities: Attested capabilities.
            peer_name: Optional human-readable peer name.
            started: Handshake start time; defaults to now.
            user_context: End-user context for OBO flows.

        Returns:
            A ``HandshakeResult`` with ``verified=True``.
        """
        now = datetime.utcnow()
        start = started or now
        latency = int((now - start).total_seconds() * 1000)
        
        # Determine trust level
        if trust_score >= TIER_VERIFIED_PARTNER_THRESHOLD:
            level = "verified_partner"
        elif trust_score >= TIER_TRUSTED_THRESHOLD:
            level = "trusted"
        elif trust_score >= 400:
            level = "standard"
        else:
            level = "untrusted"
        
        return cls(
            verified=True,
            peer_did=peer_did,
            peer_name=peer_name,
            trust_score=trust_score,
            trust_level=level,
            capabilities=capabilities,
            user_context=user_context,
            handshake_started=start,
            handshake_completed=now,
            latency_ms=latency,
        )
    
    @classmethod
    def failure(
        cls,
        peer_did: str,
        reason: str,
        started: Optional[datetime] = None,
    ) -> "HandshakeResult":
        """Create a failed handshake result.

        Args:
            peer_did: The peer's DID that failed verification.
            reason: Human-readable explanation of the failure.
            started: Handshake start time; defaults to now.

        Returns:
            A ``HandshakeResult`` with ``verified=False`` and the
            ``rejection_reason`` populated.
        """
        now = datetime.utcnow()
        start = started or now
        latency = int((now - start).total_seconds() * 1000)
        
        return cls(
            verified=False,
            peer_did=peer_did,
            trust_score=0,
            handshake_started=start,
            handshake_completed=now,
            latency_ms=latency,
            rejection_reason=reason,
        )


class TrustHandshake:
    """
    Implements IATP trust handshakes.
    
    The handshake verifies:
    1. Agent identity (via signature verification)
    2. Trust score (from registry/Nexus)
    3. Capabilities (attestation)
    
    Target: <200ms for cross-cloud handshakes.
    
    Features (from A2A review):
    - TTL-based verification caching
    - Synchronous verification option
    """
    
    MAX_HANDSHAKE_MS = 200
    DEFAULT_CACHE_TTL_SECONDS = 900  # 15 minutes
    DEFAULT_TIMEOUT_SECONDS = 30.0
    
    def __init__(
        self,
        agent_did: str,
        identity: Optional[AgentIdentity] = None,
        cache_ttl_seconds: int = DEFAULT_CACHE_TTL_SECONDS,
        timeout_seconds: float = DEFAULT_TIMEOUT_SECONDS,
    ):
        """Initialise the trust handshake handler.

        Args:
            agent_did: This agent's DID (must start with
                ``"did:mesh:"``).
            identity: Optional ``AgentIdentity`` used for
                cryptographic signing.
            cache_ttl_seconds: Seconds to cache successful
                verification results. Must be non-negative.
            timeout_seconds: Maximum seconds to wait for a single
                handshake. Must be positive.

        Raises:
            HandshakeError: If ``agent_did`` is empty or does not
                match the ``did:mesh:`` pattern, or if
                ``cache_ttl_seconds`` is negative.
            ValueError: If ``timeout_seconds`` is not positive.
        """
        if not agent_did or not agent_did.strip():
            raise HandshakeError("agent_did must not be empty")
        if not agent_did.startswith("did:mesh:"):
            raise HandshakeError(
                f"agent_did must match 'did:mesh:' pattern, got: {agent_did}"
            )
        if cache_ttl_seconds < 0:
            raise HandshakeError(
                f"cache_ttl_seconds must be non-negative, got: {cache_ttl_seconds}"
            )
        if timeout_seconds <= 0:
            raise ValueError(
                f"timeout_seconds must be positive, got: {timeout_seconds}"
            )
        self.agent_did = agent_did
        self.identity = identity
        self.timeout_seconds = timeout_seconds
        self._pending_challenges: dict[str, HandshakeChallenge] = {}
        self._verified_peers: dict[str, tuple[HandshakeResult, datetime]] = {}
        self._cache_ttl = timedelta(seconds=cache_ttl_seconds)
    
    def _get_cached_result(self, peer_did: str) -> Optional[HandshakeResult]:
        """Get cached verification result if still valid."""
        if peer_did in self._verified_peers:
            result, timestamp = self._verified_peers[peer_did]
            if datetime.utcnow() - timestamp < self._cache_ttl:
                return result
            # Expired - remove from cache
            del self._verified_peers[peer_did]
        return None
    
    def _cache_result(self, peer_did: str, result: HandshakeResult) -> None:
        """Cache a verification result with timestamp."""
        self._verified_peers[peer_did] = (result, datetime.utcnow())
    
    def clear_cache(self) -> None:
        """Clear all cached peer verification results.

        Subsequent calls to :meth:`initiate` will perform fresh
        handshakes regardless of previous outcomes.
        """
        self._verified_peers.clear()
    
    async def initiate(
        self,
        peer_did: str,
        protocol: str = "iatp",
        required_trust_score: int = 700,
        required_capabilities: Optional[list[str]] = None,
        use_cache: bool = True,
    ) -> HandshakeResult:
        """
        Initiate a trust handshake with a peer.
        
        Three-phase handshake:
        1. Challenge: Send nonce to peer
        2. Response: Peer signs nonce + attestation
        3. Verification: Verify signature + trust score
        
        Args:
            peer_did: The peer's DID
            protocol: Protocol to use (default: iatp)
            required_trust_score: Minimum trust score required
            required_capabilities: Required capabilities (optional)
            use_cache: Whether to use cached results (default: True)
            
        Returns:
            HandshakeResult with verification status
        """
        # Check cache first
        if use_cache:
            cached = self._get_cached_result(peer_did)
            if cached:
                return cached
        
        start = datetime.utcnow()
        
        try:
            result = await asyncio.wait_for(
                self._do_initiate(peer_did, required_trust_score, required_capabilities, start),
                timeout=self.timeout_seconds,
            )
            return result
        except asyncio.TimeoutError:
            raise HandshakeTimeoutError(
                f"Handshake with {peer_did} exceeded {self.timeout_seconds}s timeout"
            )
        except HandshakeTimeoutError:
            raise
        except Exception as e:
            return HandshakeResult.failure(
                peer_did, f"Handshake error: {str(e)}", start
            )

    async def _do_initiate(
        self,
        peer_did: str,
        required_trust_score: int,
        required_capabilities: Optional[list[str]],
        start: datetime,
    ) -> HandshakeResult:
        """Execute the core handshake phases (challenge, response, verify)."""
        challenge: Optional[HandshakeChallenge] = None
        try:
            # Phase 1: Generate and send challenge
            challenge = HandshakeChallenge.generate()
            self._pending_challenges[challenge.challenge_id] = challenge
            
            # Phase 2: Get response (would be async HTTP in production)
            response = await self._get_peer_response(peer_did, challenge)
            
            if not response:
                return HandshakeResult.failure(
                    peer_did, "No response from peer", start
                )
            
            # Phase 3: Verify response
            verification = await self._verify_response(
                response, challenge, required_trust_score, required_capabilities
            )
            
            if not verification["valid"]:
                return HandshakeResult.failure(
                    peer_did, verification["reason"], start
                )
            
            # Reconstruct UserContext from response if present
            response_user_ctx = None
            if response.user_context:
                response_user_ctx = UserContext(**response.user_context)

            result = HandshakeResult.success(
                peer_did=peer_did,
                trust_score=response.trust_score,
                capabilities=response.capabilities,
                started=start,
                user_context=response_user_ctx,
            )
            
            # Cache successful result
            self._cache_result(peer_did, result)
            return result
        finally:
            # Cleanup
            if challenge and challenge.challenge_id in self._pending_challenges:
                del self._pending_challenges[challenge.challenge_id]
    
    async def respond(
        self,
        challenge: HandshakeChallenge,
        my_capabilities: list[str],
        my_trust_score: int,
        private_key: Any = None,  # Deprecated; use identity parameter
        identity: Optional[AgentIdentity] = None,
        user_context: Optional[UserContext] = None,
    ) -> HandshakeResponse:
        """Respond to a trust handshake challenge.

        Signs the challenge with the agent's private key and attests
        the agent's capabilities and trust score.

        Args:
            challenge: The incoming ``HandshakeChallenge`` to respond
                to.
            my_capabilities: Capability strings this agent holds.
            my_trust_score: This agent's current trust score.
            private_key: *Deprecated* — use the ``identity`` parameter
                instead.
            identity: ``AgentIdentity`` to sign with. Falls back to
                the instance-level identity.
            user_context: Optional end-user context for OBO flows.

        Returns:
            A signed ``HandshakeResponse``.

        Raises:
            ValueError: If the challenge has expired.
        """
        # Check challenge not expired
        if challenge.is_expired():
            raise ValueError("Challenge expired")
        
        # Generate response nonce
        response_nonce = secrets.token_hex(16)
        
        # Create signature payload
        payload = f"{challenge.challenge_id}:{challenge.nonce}:{response_nonce}:{self.agent_did}"
        
        # Sign with Ed25519 if identity available, fall back to SHA256
        _id = identity or (self.identity if hasattr(self, 'identity') else None)
        if _id and _id._private_key is not None:
            signature = _id.sign(payload.encode())
            pub_key = _id.public_key
        else:
            signature = hashlib.sha256(payload.encode()).hexdigest()
            pub_key = hashlib.sha256(self.agent_did.encode()).hexdigest()
        
        return HandshakeResponse(
            challenge_id=challenge.challenge_id,
            response_nonce=response_nonce,
            agent_did=self.agent_did,
            capabilities=my_capabilities,
            trust_score=my_trust_score,
            signature=signature,
            public_key=pub_key,
            user_context=user_context.model_dump() if user_context else None,
        )
    
    async def _get_peer_response(
        self,
        peer_did: str,
        challenge: HandshakeChallenge,
    ) -> Optional[HandshakeResponse]:
        """
        Send challenge to peer and get response.
        
        In production, this would:
        1. Resolve peer DID to endpoint
        2. POST challenge to peer's IATP endpoint
        3. Receive and parse response
        """
        # Simulate peer response for now
        # In production, would make HTTP request to peer
        await asyncio.sleep(0.05)  # Simulate network latency
        
        response_nonce = secrets.token_hex(16)
        sim_payload = f"{challenge.challenge_id}:{challenge.nonce}:{response_nonce}:{peer_did}"
        
        return HandshakeResponse(
            challenge_id=challenge.challenge_id,
            response_nonce=response_nonce,
            agent_did=peer_did,
            capabilities=["read:data", "write:reports"],
            trust_score=750,
            signature=hashlib.sha256(sim_payload.encode()).hexdigest(),
            public_key=hashlib.sha256(peer_did.encode()).hexdigest(),
        )
    
    async def _verify_response(
        self,
        response: HandshakeResponse,
        challenge: HandshakeChallenge,
        required_score: int,
        required_capabilities: Optional[list[str]],
    ) -> dict:
        """
        Verify a handshake response.
        
        Checks:
        1. Challenge ID matches
        2. Signature is valid
        3. Trust score meets threshold
        4. Required capabilities present
        """
        # Verify challenge ID
        if response.challenge_id != challenge.challenge_id:
            return {"valid": False, "reason": "Challenge ID mismatch"}
        
        # Verify not expired
        if challenge.is_expired():
            return {"valid": False, "reason": "Challenge expired"}
        
        # Verify signature: try Ed25519 first, fall back to SHA256
        payload = f"{response.challenge_id}:{challenge.nonce}:{response.response_nonce}:{response.agent_did}"
        try:
            temp = AgentIdentity.model_construct(public_key=response.public_key)
            sig_valid = temp.verify_signature(payload.encode(), response.signature)
        except Exception:
            sig_valid = False
        if not sig_valid:
            expected = hashlib.sha256(payload.encode()).hexdigest()
            if response.signature != expected:
                return {"valid": False, "reason": "Signature verification failed"}
        
        # Verify trust score
        if response.trust_score < required_score:
            return {
                "valid": False,
                "reason": f"Trust score {response.trust_score} below required {required_score}"
            }
        
        # Verify capabilities
        if required_capabilities:
            missing = set(required_capabilities) - set(response.capabilities)
            if missing:
                return {
                    "valid": False,
                    "reason": f"Missing capabilities: {missing}"
                }
        
        return {"valid": True, "reason": None}
    
    def create_challenge(self) -> HandshakeChallenge:
        """Create and register a new challenge for an incoming handshake.

        The challenge is stored internally so it can later be matched
        against the peer's response.

        Returns:
            A fresh ``HandshakeChallenge`` ready to send to a peer.
        """
        challenge = HandshakeChallenge.generate()
        self._pending_challenges[challenge.challenge_id] = challenge
        return challenge
    
    def validate_challenge(self, challenge_id: str) -> bool:
        """Check if a challenge ID is valid and has not expired.

        Args:
            challenge_id: The challenge identifier to validate.

        Returns:
            ``True`` if the challenge exists and is still within its
            time-to-live window.
        """
        challenge = self._pending_challenges.get(challenge_id)
        if not challenge:
            return False
        return not challenge.is_expired()
