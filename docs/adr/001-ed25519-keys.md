# ADR-001: Ed25519 for Agent Identity Keys

## Status

Accepted

## Context

AgentMesh requires a cryptographic signing algorithm for agent identity, DID generation,
delegation chain signatures, and trust handshake challenge–response. The algorithm must
support high-throughput signing (agents sign every message), small key/signature sizes
(keys are embedded in headers and AI Cards), and deterministic output (for reproducible
verification across mesh nodes).

Candidates evaluated:

| Algorithm | Key Size | Signature Size | Sign (ops/s) | Verify (ops/s) | Deterministic |
|-----------|----------|----------------|--------------|-----------------|---------------|
| RSA-2048 | 256 B | 256 B | ~1 000 | ~30 000 | Yes |
| RSA-4096 | 512 B | 512 B | ~200 | ~10 000 | Yes |
| ECDSA P-256 | 32 B | 64 B | ~20 000 | ~10 000 | No* |
| Ed25519 | 32 B | 64 B | ~50 000 | ~20 000 | Yes |

\* ECDSA requires a random nonce per signature; nonce reuse leaks the private key.

Additional considerations:

- **NaCl/libsodium ecosystem**: Ed25519 is the default signing primitive in NaCl and
  libsodium, which are available in every major language. This simplifies cross-language
  agent interoperability.
- **DID method compatibility**: The `did:key` specification uses Ed25519 as its primary
  algorithm. Our `did:mesh` format derives from the public key, making Ed25519 a natural
  fit.
- **SPIFFE alignment**: SPIFFE SVIDs support Ed25519 for JWT-SVID signing, enabling
  direct key reuse between Layer 1 identity and mTLS workload identity.
- **No padding/encoding complexity**: Ed25519 signatures are fixed 64 bytes — no ASN.1
  DER encoding or variable-length padding like RSA PKCS#1.

## Decision

Use **Ed25519** (RFC 8032) as the sole signing algorithm for agent identity.

Implementation details:

- Key generation via `cryptography.hazmat.primitives.asymmetric.ed25519`
- Public keys encoded as base64 for transport (`AgentIdentity.public_key`)
- Key ID format: `key-<sha256_first_16_chars>` for efficient lookup
- Private keys stored as `_private_key` and never serialized
- Signatures returned as base64-encoded strings via `AgentIdentity.sign(data: bytes)`
- DID derivation: `did:mesh:<sha256(public_key_bytes)[:32]>`

## Consequences

### Positive

- **Performance**: ~50 000 sign operations/second enables signing every inter-agent
  message without measurable latency.
- **Compact keys**: 32-byte public keys fit comfortably in HTTP headers
  (`X-Agent-Public-Key`) and AI Card JSON documents.
- **Deterministic signatures**: The same message and key always produce the same
  signature, enabling reproducible verification and caching.
- **Ecosystem compatibility**: NaCl/libsodium bindings exist for Python, Go, Rust, JS,
  Java, and .NET — any agent runtime can verify signatures.
- **No nonce management**: Unlike ECDSA, no random nonce is required, eliminating an
  entire class of implementation bugs that could leak private keys.

### Negative

- **No key agreement**: Ed25519 is signing-only. If AgentMesh later needs Diffie-Hellman
  key exchange (e.g., for encrypted channels), we would need X25519 conversion or a
  separate key pair. Mitigated by the fact that X25519 uses the same curve and conversion
  is straightforward (RFC 7748).
- **Single algorithm lock-in**: If Ed25519 is broken or deprecated, migrating all agent
  identities requires a coordinated rotation. Mitigated by the key ID abstraction and
  credential TTL (15 min) which limits exposure window.
- **No post-quantum resistance**: Ed25519 is vulnerable to quantum attacks. This is
  acceptable for the current threat model; a future ADR will address hybrid
  post-quantum schemes when standards mature (e.g., ML-DSA / Dilithium).
